#!/bin/sh
# shellcheck disable=SC2015,SC2059,SC2048
IFS=""
operand(){
  printf '%s: missing operand' "${0##*/}"
  [ ! "$2" -a "$1" ] && { printf " after '%s'\n" "$1"
    printf 'Two strings must be given when translating.'
  }
  echo; exit 1
} # handle missing args

# IFS="<>"
# set -- "$in"
# for i in $*; do # $* is intended
#   [ ! "$out" ] && { out="$i";:;} || { out="$out$d$i";}
# done
## this system is REQUIRED for escape replacement, but is unstable

[ ! "$1" -o ! "$2" ] && { operand "$@" ;}
## setup replacement
  IFS="" r="$(printf "${1}")" # using this allows matching escapes
  [ ! "$r" -a "$1" = "\n" ] && { r='
';}
##
while read -r in || [ -n "$in" ]; do
  while [ -n "$in" ]; do
    next=${in#?}
    case "${in%$next}" in
      "${r}")
        printf '%s' "${2}"
      ;;
      *)
        printf '%s' "${in%$next}"
    esac
    in="$next"
  done
done <&0
# this always works but cannot match escapes

printf '%s\n' "$out"
